/***********************************************
 The module, `@(module_name)`, scales the input PWL signal in piecewise linear 
 way. That is,  it provides a way to build a DC transfer function using 
 piecewise linear approximation. Thus it enables to model distortion effect 
 (e.g. compressed gain) before going though a filter. Event control 
 (asserted by "wakeup" signal) is also implemented here.

 lookup table index of x
  x[0]  <  x        then index = -1,        out = y[0]*in;
  x[0] <= x < x[1]  then index = 0,         out = y[0]*in;
  x[1] <= x < x[2]  then index = 1,         out = y[1]*in;
  x[2] <= x < x[3]  then index = 2,         out = y[2]*in;
  ...
  x[LUTSize-1] <= x then index = LUTSize-1, out = y[LUTSize-1]*in;

 dctxf.py will help you build such models from either
  - simulation data (e.g. Ids vs. Vgs), or
  - an analytic expression (fosc vs Vctrl)
***********************************************/

@# TODO: Indexing in SVerilog is computationally expensive, and I think there is a way to improve this.

module @(module_name) (
  input pwl in,
  output pwl out
);

timeunit 1fs;
timeprecision 1fs;

`get_timeunit
PWLMethod pm=new;

pwl in_prev;
event wakeup;
integer index;
real t;
real in_value;
real slope;
real scale;
real dTr;
real out_cur;
time dT=1;
time dTm, t_prev;
reg event_in=1'b0;

///////////////////////////////////////
// LUT of DC Transfer Curve
///////////////////////////////////////
parameter integer LUTSize=@(len(lutx));
real lutx[LUTSize-1:0]; // x-axis
real luty[LUTSize-1:0]; // gain 
real ly[LUTSize-1:0];   // offset to handle when luty[j]==0
initial begin
@[for i in range(len(lutx))]
lutx[@i] = @(lutx[i]); luty[@i] = @(luty[i]); ly[@i] = @(ly[i]); @[end for]
end
///////////////////////////////////////


initial #1 ->> wakeup;

always @@(`pwl_event(in) or wakeup) begin
  dTm = $realtime - t_prev;
  event_in = `pwl_check_diff(in, in_prev);
  if (((dT==dTm)&&(dTm>=1)) || event_in) begin
    if (event_in) in_prev = in;
    t = `get_time;              // current time
    in_value = pm.eval(in, t);  // current value
    slope = in.b;               // slope of the input
  
    // input changes and the current index is NOT valid
    index = find_region_@(module_name)(in_value);  // update index
    // evaluate the output at current time
    scale = luty[index];            // get scale(gain) from the LUT
    out_cur = ly[index]+scale*(in_value-lutx[index]);
    out = '{out_cur, scale*in.b, t}; 
    // schedule next event if necessary
    // calculate when the input will hit the inflection point.
    dTr = calculate_dx_@(module_name)(in_value, slope, index); 
    dTr = min(dTr,1);
    //dTr = time'(dTr/TU)*TU;
    if (dTr > 0) begin
      dTr = max(dTr,TU);
      dT = time'(dTr/TU);
      ->> #(dT) wakeup; // schedule an event after dT
      t_prev = $realtime;
    end
  end
end

@#// check if the value is in the region lutx[index]
@#/*********************************************************************
@#function logic check_region_@(module_name)(real value, integer index);
@#begin
@#  if (index == LUTSize-1) begin // boundary condition
@#    if (value >= lutx[index]) return 1'b1;
@#    else return 1'b0;
@#  end
@#  else begin
@#    if (value >= lutx[index] && value < lutx[index+1]) return 1'b1;
@#    else return 1'b0;
@#  end
@#end
@#endfunction
@#*********************************************************************/

`protect
// for given value, find the index of LUT (region)
function integer find_region_@(module_name) (real value);
int idx[$];
begin
  if (value < lutx[1]) return 0;
  else if (value >= lutx[LUTSize-1]) return LUTSize-1;
  else begin
    idx = lutx.find_index with (item > value);
    return idx[0]-1;
  end
end
endfunction

// calculate the next event where inflection of transfer curve 
// for given input (value, slope)
function real calculate_dx_@(module_name)(real value, real slope, integer index);
real nxt_value;
real sgn_sl;
real dx;
begin
  sgn_sl = sgn(slope);
  if (sgn_sl == 0) return 0.0;
  if ((value >= lutx[LUTSize-1]) && (sgn_sl > 0)) return 0.0;
  if ((value <= lutx[0]) && (sgn_sl < 0)) return 0.0;
  // the first two if handle boundary condition
  if (value > lutx[LUTSize-1]) begin
    dx = (lutx[LUTSize-1]-value)/slope;
    if (dx < TU) return TU;
    else return dx;
  end
  else if (value < lutx[0]) begin
    dx = (lutx[0]-value)/slope;
    if (dx < TU) return TU;
    else return dx;
  end
  if (sgn_sl > 0) nxt_value = lutx[index+1];
  else nxt_value = lutx[index];
  dx = (nxt_value-value)/slope;
  if (dx < TU) return TU;
  else return dx;
end
endfunction
`endprotect

endmodule
