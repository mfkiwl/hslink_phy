

/****************************************************************
* This code is automatically generated by "mGenero"
* at Tue, 05 Jun 2018 02:32:23.
*
* Copyright (c) 2014-Present by Stanford University. All rights reserved.
*
* The information and source code contained herein is the property
* of Stanford University, and may not be disclosed or reproduced
* in whole or in part without explicit written authorization from
* Stanford University.
* For more information, contact bclim@stanford.edu
****************************************************************/
/****************************************************************

Copyright (c) 2016-2018 Stanford University. All rights reserved.

The information and source code contained herein is the 
property of Stanford University, and may not be disclosed or
reproduced in whole or in part without explicit written 
authorization from Stanford University.

* Filename   : oscillator.template.sv
* Author     : Byongchan Lim (bclim@stanford.edu)
* Description: Generic oscillator template

* Note       :
  - Gain compression is valid only if 'actl' generic pin exists

* Todo       :

* Revision   :
  - 00/00/00: Initial commit

****************************************************************/

module ringosc #(
// parameters here
  parameter real etol_i = 1e-6, // current resolution
  parameter real etol_ph = 0.01, // resolution of normalized phase ( [0.0,1.0) )
  parameter real jitter = 0.0, // jitter in normalized phase ( [0.0,1.0) )
  parameter real etol_v = 0.005, // voltage resolution
  parameter real etol_vtune = etol_v // voltage resolution
) (
  output logic  cko, // positive output clock
  input pwl vdd , // power supply
  input pwl vreg , // control voltage
  output logic  ckob // negative output clock
);

`get_timeunit
PWLMethod pm=new;

// map pins between generic names and user names, if they are different
logic  outp;
pwl actl ;
logic  outn;
assign cko = outp ;
assign actl = vreg ;
assign ckob = outn ; 
//---SNIPPET ON
///////////////////
// CODE STARTS HERE
///////////////////

//----- wires, assignment
pwl PWL1 = `PWL1;
pwl phase;  // [0, modulo*2.0)
pwl freq;   // instantaneous frequency
pwl actl_lmt; // limited range of actl

real t0;  // temp time var.
real vdd_r;
real vss_r;
real actl_r; 

real kvco;
real freq_os;
real actl_ctr;
real freq_ctr;

real vi_min, vi_max;
pwl actl_min, actl_max;
real freq_max, freq_min;

assign outn = ~outp;

//----- body
`protect
//pragma protect 
//pragma protect begin

//-- system's parameter 

localparam real etol_vdd = etol_v;
localparam real etol_vss = etol_v;

// discretization of control inputs
pwl2real #(.dv(etol_vdd)) xp2r_vdd (.in(vdd), .out(vdd_r)); // pwl-to-real of vdd

// update parameters as control inputs/mode inputs change

always @(vdd_r, vss_r, actl_r, outn) begin

  actl_ctr = 0.7974376;
  freq_max = 3658809000.0;
  vi_max = 0.9698702;
  freq_ctr = 2477095000.0;
  kvco = 6853198000.0;
  freq_min = 1295380000.0;
  vi_min = 0.6250051;

  freq_os = freq_ctr - kvco*actl_ctr; // frequency at vi=0

  actl_min = '{vi_min,0,0};
  actl_max = '{vi_max,0,0};

end

// calculate frequency in pwl

pwl_limiter uLIM0 ( .scale(PWL1), .maxout(actl_max), .minout(actl_min), .in(actl), .out(actl_lmt) );

  pwl _freq[2]; real _k_freq[2];
  assign _freq = '{actl_lmt, PWL1};
  assign _k_freq = '{kvco, freq_os};
pwl_add #(.no_sig(2)) uFREQ ( .enable(), .in(_freq), .scale(_k_freq), .out(freq) );

// frequency-to-phase
pwl_integrator_w_reset #(.etol(etol_ph), .modulo(0.5), .noise(jitter), .en_filter(0)) uph2ck ( .gain(1.0), .si(freq), .so(phase), .trigger(outp), .reset(1'b0), .reset_sig() );

//pragma protect end
`endprotect
endmodule
